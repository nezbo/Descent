static_diagram FORMEL_PLAYER
component
	class PLAYER -- The actual player, playing the game
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			connection: CONNECTION -- What is your connection?
			isOverlord: BOOLEAN -- What is your role?
			isServer: BOOLEAN -- Are you client or server?
			uniqueID: INTEGER -- What is your unique player ID?
			setUniqueID: Void -- Your unique player ID is this!
				-> id: INTEGER
				ensure
					uniqueID = id;
			end
	end
			
	class HERO_PARTY -- A party of heroes
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "01-12-2011";
		feature
			numberOfHeroes: INTEGER -- How many players are in the HeroParty?
			numberOfHeroesYetToAct: INTEGER -- How many players have yet to take their turn?
				ensure
					Result >= 0;
					Result <= numberOfPlayers;
			end
			hasHeroActedYet: BOOLEAN -- Has 'this' player yet to take their turn?
				-> hero: Hero
				require
					hero /= Void
			end
			conquestTokens: INTEGER -- How many conquest tokens do the players have?
			isConquestPoolEmpty: BOOLEAN -- How many conquest tokens do the players have?
				ensure
					Result -> conquestTokens = 0;
			end
			heroHasActed: Void -- Remove 'this' player from the list of players yet to act!
				-> hero: Hero
				require
					hero /= Void;
					hasHeroActedYet = false;
				ensure
					hasHeroActedYet = true;
					numberOfHeroesYetToAct = old numberOfHeroesYetToAct - 1;
			end
			resetYetToAct: Void -- Reset list of Hero yet to act!
				require
					numberOfHeroesYetToAct = 0;
				ensure
					numberOfHeroesYetToAct = numberOfHeroes;
			end
			removeConquestTokens: Void -- Remove 'this' number of conquest tokens from the pool of tokens!
				-> INTEGER: tokens
				require
					tokens > 0;
				ensure
					conquestTokens = old conquestTokens - tokens;
			end
			addConquestTokens: Void -- Add 'this' number of conquest tokens to the pool of tokens!
				-> INTEGER: tokens
				require
					tokens > 0;
				ensure
					conquestTokens = old conquestTokens + tokens;
			end
		invariant
			numberOfHeroes >= 2 and numberOfHeroes <= 4;
			conquestTokens >= 0;
	end
	
	class HERO_PLAYER
		indexing
			author: "Jonas Breindahl";
		feature
			hero: HERO -- What hero are you playing?
	end
	
	class OVERLORD -- The role of a overlord, that a hero can be
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "30-11-2011";
		feature
			numberOfOverlordCardsInHand: INTEGER -- The role of a overlord, that a hero can be
			threatTokens: INTEGER -- How many threat tokens do you have?
			overlordCardsInHand: SEQUENCE[OVERLORD_CARD] -- What cards do you have?
				ensure
					Result.length = numberOfOverlordCardsInHand;
			end
			overlordCardsInDeck: INTEGER -- How many cards are in your overlord deck?
			overlordCardsInDiscard: INTEGER -- How many cards are in your overlord discard?
			drawOverlordCards: Void -- Draw 'this' many cards!
				-> cards: INTERGER
				require
					cards > 0;
				ensure
					overlordCardsInHand = old overlordCardsInHand + cards;
			end
			shuffleOverlordDiscardIntoDeck: Void -- Shuffle the overlord discard into the deck!
				require
					overlordCardsInDeck = 0;
				ensure
					overlordCardsInDiscard = 0;
					overlordCardsInDeck = old overlordCardsInDiscard;
			end
		invariant
			-- When it is not the overlords turn, the overlord cannot have more than 7 cards in hand.
			true;
	end	
	
	class FIGURE
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "05-12-2011";
		feature
			uniqueID: INTEGER -- What is your unique figure ID?
			name: STRING -- What is your name?
			maxHealth: INTEGER -- What is your max health?
			health: INTEGER -- What is your health right now?
			armor: INTEGER -- What is your armor?
			speed: INTEGER -- What is your speed?
			speedLeft: INTEGER -- How much speed do you have left?
			attacksLeft: INTEGER -- How many attacks do you have left?
			diceForAttacks: SEQUENCE[DICE] -- What dice do you use to attack?
			abilities: SEQUENCE[ABILITY] -- What abilities do you have?
			effects: SEQUENCE[EFFECT] -- What effect are on you?
			addHealth: Void -- Add 'this' amount of health!
				-> INTEGER: healthAmount
				require
					healthAmount > 0;
				ensure
					old health + healthAmount > maxHealth -> health = maxHealth;
					old health + healthAmount <= maxHealth -> health = old health + healthAmount;
			end
			removeHealth: Void -- Lose 'this' amount of health!
				-> INTEGER: healthAmount
				require
					healthAmount > 0;
				ensure
					old health - healthAmount < 0 -> health = 0;
					old health - healthAmount >= 0 -> health = old health - healthAmount;
			end
			addSpeed: Void -- Add 'this' amount of speed!
				-> INTEGER: speedAmount
				require
					speedAmount > 0;
				ensure 
					speed = old speed + speedAmount;
			end
			removeSpeed: Void -- Lose 'this' amount of speed!
				-> INTEGER: speedAmount
				require
					speedAmount > 0;
				ensure
					old speed - speedAmount < 0 -> speed = 0;
					old speed - speedAmount >= 0 -> speed = old speed - speedAmound;
			end
		invariant
			name.length > 0;
			maxHealth > 0;
			health >= 0 and health <= maxHealth;
			speed > 0;
			armor >= 0;
			speedLeft >= 0;
			attacksLeft >= 0;
			
	end
	
	class HERO
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			maxFatique: INTEGER -- What is your max fatique?
			fatique: INTEGER -- What is your fatique right now?
			numberOfSkills: INTEGER -- How many skills do you have in MELEE/RANGED/MAGIC?
				-> ATTACK_TYPE: type
				require
					type /= Void;
			end
			addFatique: Void -- Add 'this' amount of fatique!
				-> fatiqueAmount: INTEGER
				require
					fatiqueAmount > 0;
				ensure
					old fatique + fatiqueAmount > maxFatique -> fatique = maxFatique;
					old fatique + fatiqueAmount <= maxFatique -> fatique = old fatique + fatiqueAmount;
			end
			removeFatique: Void -- Lose 'this' amount of fatique!
				-> fatiqueAmount: INTEGER
				require
					fatiqueAmount > 0;
					fatigueAmount <= fatigue;
				ensure
					old fatique + fatiqueAmount < 0 -> fatique = 0;
					old fatique + fatiqueAmount >= 0 -> fatique = old fatique + fatiqueAmount;
			end
		invariant
			fatique <= maxFatique;
			fatique > 0;
	end
	
	class MONSTER -- A monster, controlled by the overlord
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "02-12-2011";
		inherit
			FIGURE
	end
			
end

static_diagram FORMAL_HERO_STUFF
component
	class SKILL -- The skill-cards of a hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			skillType: ATTACK_TYPE -- What type of skill are you?
			name: STRING -- What is your name?
			abilities: SEQUENCE[ABILITY] -- What are your abilities?
		invariant
			true;
			-- A Skill cannot have more than one type
	end
	
	class INVENTORY
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			maxHands: INTEGER -- How many hands do you have?
			freeHands: INTEGER -- How many hands do you have free?
            weaponEquipped: EQUIPMENT -- What weapons do you have in your hands?
			armorEquipped: EQUIPMENT -- What armor do you have equipped?
			shieldEquipped: EQUIPMENT -- What shield do you have equipped?
			otherItemsEquipped: SEQUENCE[EQUIPMENT] -- What other items do you have equipped?
			potionsEquipped: SEQUENCE[EQUIPMENT] -- What potions do you have equipped?
			equipmentInBackpack: SEQUENCE[EQUIPMENT] -- What equipment do you have in your backpack?
            maxPotions: INTEGER -- How many potions can you hold?
            maxInBackpack: INTEGER -- How many items can you hold in your backpack?
            maxOtherItems: INTEGER -- How many other items can you hold?
			equipWeapon: Void -- Equip 'this' weapon!
				-> weapon: EQUIPMENT
				require
                    weapon /= Void;
					freeHands <= weapon.hands();
				ensure
					weaponEquipped = weapon;
                    freeHands = old freeHands - weapon.hands();
			end
			equipArmor: Void -- Equip 'this' armor!
				-> armor: EQUIPMENT
				require
					armor /= Void;
				ensure
					armorEquipped = armor;
			end
			equipShield: Void -- Equip 'this' armor!
				-> shield: EQUIPMENT
				require
					shield /= Void;
					freeHands <= shield.hands();
				ensure
					shieldEquipped = shield;
                    freeHands = old freeHands - shield.hands();
			end
			equipOtherItem: Void -- Equip 'this' other item!
                -> index: INTEGER
				-> item: EQUIPMENT
				require
					otherItemsEquipped.length < 3;
				ensure
					otherItemsEquipped.length = old otherItemsEquipped.length + 1;
			end
			equipPotion: Void -- Equip 'this' potion!
                -> index: INTEGER
				-> potion: EQUIPMENT
				require
					potionsEquipped.length < 3;
				ensure
					potionsEquipped.length = old potionsEquipped.length + 1;
			end
			addEquipmentToBackpack: Void -- Put 'this' Equipment in your backpack!
                -> index: INTEGER
				-> equipment: EQUIPMENT
				require
					spaceInBackpack > 0;
				ensure
					spaceInBackpack = old spaceInBackpack - 1;
			end
            unequipWeapon: EQUIPMENT -- Unequip 'this' weapon!
                require
                    weaponEquipped /= Void;
                ensure
                    Result = old weaponEquipped;
                    freeHands = old freeHands + Result.hands();
                    weaponEquipped = Void;
            end
            unequipArmor: EQUIPMENT -- Unequip 'this' armor!
                require
                    armorEquipped /= Void;
                ensure
                    Result = old armorEquipped;
                    armorEquipped = Void;
            end
            unequipShield: EQUIPMENT -- Unequip 'this' shield!
                require
                    shieldEquipped /= Void;
                ensure
                    Result = old shieldEquipped;
                    freeHands = old freeHands + Result.hands();
                    shieldEquipped = Void;
            end
            unequipOther: EQUIPMENT -- Unequip 'this' other!
                -> index: INTEGER
                require
                    0 < index and index < maxOther;
                    otherItemsEquipped.get(index) /= Void;
                ensure
                    otherItemsEquipped.get(index) = Void;
                    Result = old otherItemsEquipped.get(index);
            end
            unequipPotion: EQUIPMENT -- Unequip 'this' potion!
                -> index: INTEGER
                require
                    0 < index and index < maxPotions;
                    potionsEquipped.get(index) /= Void;
                ensure
                    potionsEquipped.get(index) = Void;
                    Result = old potionsEquipped.get(index);
            end
            unequipFromBackpack: EQUIPMENT -- Remove 'this' from your backpack!
                -> index: INTEGER
                require
                    0 < index and index < maxInBackpack;
                    backpackEquipped.get(index) /= Void;
                ensure
                    backpackEquipped.get(index) = Void;
                    Result = old backpackEquipped.get(index);
            end
		invariant
            0 < freeHands and freeHands < maxHands;
	end
	
	class EQUIPMENT -- Equipment can be worn by the hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "05-12-2011";
		feature
			tapped BOOLEAN -- Are you tapped right now?
			name: STRING -- What is your name?
			equipmentType: EQUIPMENT_TYPE -- What type of equipment are you?
			buyPrice: INTEGER -- What is your price?
			abilities: SEQUENCE[SURGE_ABILITY] -- What are your abilities?
			handsToWield: INTEGER -- How many hands do you use?
		invariant
			-- "An equipment may only be tapped one time per round"
			true;
	end
	
	class SURGE_ABILITY -- A surge power on a piece of equipment
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			cost: INTEGER -- How many surges do you cost?
			ability: Ability -- What ability do you grant?
		invariant
			cost >= 0;
			ability /= Void;
	end
		
	class TRAINING_TOKEN -- A token that give extra dice in a specific kind of attack
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			type: ATTACK_TYPE -- What attack do you grant bonus to?
	end
	
	class POTION -- A potion, that can either be on a square, or equipped on a Hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		inherit
			EQUIPMENT
		feature
			type POTION_TYPE -- What kind of potion are you?
	end
end

static_diagram FORMAL_OVERLORD_STUFF
component
	class OVERLORD_CARD
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			name: STRING -- What is your name? Your name is 'this'!
			cardDescription: STRING -- What is your description? Your description is 'this'!
			type: OVERLORD_CARD_TYPE -- What type of overlord card are you?"
			abilities: SEQUENCE[ABILITY] -- What abilities do you have?
	end
end

static_diagram FORMAL_EVENT_CLUSTER
component
	class ABILITY -- Can this ability be used now?
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			canBeUsedNow: BOOLEAN -- Can this ability be used now?
				-> GAME_STATE
	end
end

static_diagram FORMAL_BOARD_CLUSTER
component
	class BOARD -- The entire gameboard, made up of squares
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "02-12-2011";
		feature
			width: INTEGER -- What is your width?
			height: INTEGER -- What is your height?
			heroesInTown: SEQUENCE[HERO] -- What heroes are currently in town?
			withinBoard: BOOLEAN -- Is the coordinate (x/y) within the board?
				-> coord: POINT
				require 
					coord /= Void;
				ensure
					Result = coord.x >= 0 and coord.x < width 
					and coord.y >= 0 and coord.y < height;
			end
			standable: BOOLEAN -- Is this square standable?
				-> coord: POINT
				require
					withinBoard(coord.x, coord.y);
					coord /= Void;
			end
			canOverlordSpawn: BOOLEAN -- Can the overlord spawn here?
				-> coord: POINT
				require
					coord /= Void;
			end
			lineOfSight: BOOLEAN -- Is there line of sight from 'here' to 'there'?
				-> here: POINT
				-> there: POINT
				-> monstersBlock: BOOLEAN -- not included monsters?
				require
					here /= Void;
					there /= Void;
			end
			squareVisiblyByPlayers: BOOLEAN -- Is this space visible by players?
            distance: INTEGER -- What is the distance between these squares?
                -> here: POINT
                -> there: POINT
            get: SQUARE -- Can I have the square object for this coordinate?
                -> x: INTEGER
                -> y: INTEGER
            
	end
	
	class SQUARE -- A single square of the board
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			marker: MARKER -- What marker is on this square?
			figure: FIGURE -- What figure is on this square?
	end
	
	class TOWN -- When in town the players can buy, they also go there when they die
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			heroesInTown: SEQUENCE[HERO] -- What heroes are in town right now
	end
end

static_diagram FORMAL_STATE_STUFF
component
	class STATE_MANAGER
		indexing 
			author: "Martin Marcher";
		feature
			GetInstance: STATE_MANAGER -- Can I have the unique object of this class?
			CurrentState: STATE -- What is the current state?
			PreviousStates: SEQUENCE[STATE] -- What was the previous 'n' states?
				-> count: INTEGER
				require
					count > 0;
				ensure
					Result.length <= count;
			end
			NextPossibleStates: SEQUENCE[STATE] -- What are the next possible states?
	end
	class STATE_MACHINE
		indexing
			author: "Martin Marcher";
		feature
			CurrentState: STATE -- What is the current state?
			NextState: STATE -- What is the next state?
			PreviousStates: SEQUENCE[STATE] -- What was the previous 'n' states?
				-> count: INTEGER
				require
					count > 0;
				ensure
					Result.length <= count;
			end
			ChangeToNextState: Void -- Change to next state!
			PlaceStates: Void -- Place these states after the current state
				-> states: SEQUENCE[STATE]
				require
					states /= Void and states.Length > 0;
				ensure
					NextState = states.First;
			end
			invariant
				CurrentState /= Void;
				NextState /= Void;
	end
end