static_diagram FORMEL_PLAYER
component
	class PLAYER -- The actual player, playing the game
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			connection: CONNECTION -- What is your connection?
			isOverlord: BOOLEAN -- What is your role?
			isServer: BOOLEAN -- Are you client or server?
			uniqueID: INTEGER -- What is your unique player ID?
			setUniqueID: Void -- Your unique player ID is this!
				-> id: INTEGER
				ensure
					uniqueID = id;
			end
	end
			
	class HERO_PARTY -- A party of heroes
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "01-12-2011";
		feature
			numberOfHeroes: INTEGER -- How many players are in the HeroParty?
			numberOfHeroesYetToAct: INTEGER -- How many players have yet to take their turn?
				ensure
					Result >= 0;
					Result <= numberOfPlayers;
			end
			hasHeroActedYet: BOOLEAN -- Has 'this' player yet to take their turn?
				-> hero: Hero
				require
					hero /= Void
			end
			conquestTokens: INTEGER -- How many conquest tokens do the players have?
			isConquestPoolEmpty: BOOLEAN -- How many conquest tokens do the players have?
				ensure
					Result -> conquestTokens = 0;
			end
			heroHasActed: Void -- Remove 'this' player from the list of players yet to act!
				-> hero: Hero
				require
					hero /= Void;
					hasHeroActedYet = false;
				ensure
					hasHeroActedYet = true;
					numberOfHeroesYetToAct = old numberOfHeroesYetToAct - 1;
			end
			resetYetToAct: Void -- Reset list of Hero yet to act!
				require
					numberOfHeroesYetToAct = 0;
				ensure
					numberOfHeroesYetToAct = numberOfHeroes;
			end
			removeConquestTokens: Void -- Remove 'this' number of conquest tokens from the pool of tokens!
				-> INTEGER: tokens
				require
					tokens > 0;
				ensure
					conquestTokens = old conquestTokens - tokens;
			end
			addConquestTokens: Void -- Add 'this' number of conquest tokens to the pool of tokens!
				-> INTEGER: tokens
				require
					tokens > 0;
				ensure
					conquestTokens = old conquestTokens + tokens;
			end
		invariant
			numberOfHeroes >= 2 and numberOfHeroes <= 4;
			conquestTokens >= 0;
	end
	
	class HERO_PLAYER
		indexing
			author: "Jonas Breindahl";
		feature
			hero: HERO -- What hero are you playing?
	end
	
	class OVERLORD -- The role of a overlord, that a hero can be
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "30-11-2011";
		feature
			numberOfOverlordCardsInHand: INTEGER -- The role of a overlord, that a hero can be
			threatTokens: INTEGER -- How many threat tokens do you have?
			overlordCardsInHand: SEQUENCE[OVERLORD_CARD] -- What cards do you have?
				ensure
					Result.length = numberOfOverlordCardsInHand;
			end
			overlordCardsInDeck: INTEGER -- How many cards are in your overlord deck?
			overlordCardsInDiscard: INTEGER -- How many cards are in your overlord discard?
			drawOverlordCards: Void -- Draw 'this' many cards!
				-> cards: INTERGER
				require
					cards > 0;
				ensure
					overlordCardsInHand = old overlordCardsInHand + cards;
			end
			shuffleOverlordDiscardIntoDeck: Void -- Shuffle the overlord discard into the deck!
				require
					overlordCardsInDeck = 0;
				ensure
					overlordCardsInDiscard = 0;
					overlordCardsInDeck = old overlordCardsInDiscard;
			end
		invariant
			-- When it is not the overlords turn, the overlord cannot have more than 7 cards in hand.
			true;
	end	
	
	class FIGURE
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "30-11-2011";
		feature
			uniqueID: INTEGER -- What is your unique figure ID?
			name: STRING -- What is your name?
			maxHealth: INTEGER -- What is your max health?
			health: INTEGER -- What is your health right now?
			armor: INTEGER -- What is your armor?
			speed: INTEGER -- What is your speed?
			speedLeft: INTEGER -- How much speed do you have left?
			attacksLeft: INTEGER -- How many attacks do you have left?
			diceForAttacks: SEQUENCE[DICE] -- What dice do you use to attack?
			abilities: SEQUENCE[ABILITY] -- What abilities do you have?
			effects: SEQUENCE[EFFECT] -- What effect are on you?
			addHealth: Void -- Add 'this' amount of health!
				-> INTEGER: healthAmount
				require
					healthAmount > 0;
				ensure
					old health + healthAmount > maxHealth -> health = maxHealth;
					old health + healthAmount <= maxHealth -> health = old health + healthAmount;
			end
			removeHealth: Void -- Lose 'this' amount of health!
				-> INTEGER: healthAmount
				require
					healthAmount > 0;
				ensure
					old health - healthAmount < 0 -> health = 0;
					old health - healthAmount >= 0 -> health = old health - healthAmount;
			end
			addSpeed: Void -- Add 'this' amount of speed!
				-> INTEGER: speedAmount
				require
					speedAmount > 0;
				ensure 
					speed = old speed + speedAmount;
			end
			removeSpeed: Void -- Lose 'this' amount of speed!
				-> INTEGER: speedAmount
				require
					speedAmount > 0;
				ensure
					old speed - speedAmount < 0 -> speed = 0;
					old speed - speedAmount >= 0 -> speed = old speed - speedAmound;
			end
		invariant
			name.length > 0;
			maxHealth > 0;
			speed > 0;
			armor >= 0;
			speedLeft >= 0
			attacksLeft >= 0;
			
	end
	
	class HERO
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			maxFatique: INTEGER -- What is your max fatique?
			fatique: INTEGER -- What is your fatique right now?
			numberOfSkills: INTEGER -- How many skills do you have in MELEE/RANGED/MAGIC?
				-> ATTACK_TYPE: type
				require
					type /= Void;
			end
			addFatique: Void -- Add 'this' amount of fatique!
				-> INTEGER: fatiqueAmount
				require
					fatiqueAmount > 0;
				ensure
					old fatique + fatiqueAmount > maxFatique -> fatique = maxFatique;
					old fatique + fatiqueAmount <= maxFatique -> fatique = old fatique + fatiqueAmount;
			end
			removeFatique: Void -- Lose 'this' amount of fatique!
				-> INTEGER: fatiqueAmount
				require
					fatiqueAmount > 0;
					fatigueAmount <= fatigue;
				ensure
					old fatique + fatiqueAmount < 0 -> fatique = 0;
					old fatique + fatiqueAmount >= 0 -> fatique = old fatique + fatiqueAmount;
			end
		invariant
			fatique <= maxFatique;
			fatique > 0;
	end
	
	class MONSTER -- A monster, controlled by the overlord
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "02-12-2011";
		inherit
			FIGURE
	end
			
end

static_diagram FORMAL_HERO_STUFF
component
	class SKILL -- The skill-cards of a hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			skillType: ATTACK_TYPE -- What type of skill are you?
			name: STRING -- What is your name?
			abilities: SEQUENCE[ABILITY] -- What are your abilities?
		invariant
			true;
			-- A Skill cannot have more than one type
	end
	
	class INVENTORY
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			maxHands: INTEGER -- How many hands do you have?
			weaponsEquipped: SEQUENCE[EQUIPMENT] -- What weapons do you have in your hands?
			armorEquipped: EQUIPMENT -- What armor do you have equipped?
			otherItemsEquipped: SEQUENCE[EQUIPMENT] -- What other items do you have equipped?
			potionsEquipped: SEQUENCE[EQUIPMENT] -- What potions do you have equipped?
			equipmentInBackpack: SEQUENCE[EQUIPMENT] -- What equipment do you have in your backpack?
			spaceInBackPack: INTEGER -- Is there more space in your backpack?
				ensure
					Result = 3 - equipmentInBackpack.length;
			end
			equipWeapon: Void -- Equip 'this' Equipment!
				-> weapon: EQUIPMENT
				require
					weaponsEquipped.length < maxHands;
				ensure
					weaponsEquipped.length = old weaponsEquipped.length + 1;
			end
			equipArmor: Void -- Equip 'this' armor!
				-> armor: EQUIPMENT
				require
					armor = Void;
				ensure
					armor =/ Void;
					armorEquipped = armor;
			end
			equipOtherItem: Void -- Equip 'this' other item!
				-> item: EQUIPMENT
				require
					otherItemsEquipped.length < 3;
				ensure
					otherItemsEquipped.length = old otherItemsEquipped.length + 1;
			end
			equipPotion: Void -- Equip 'this' potion!
				-> potion: EQUIPMENT
				require
					potionsEquipped.length < 3;
				ensure
					potionsEquipped.length = old potionsEquipped.length + 1;
			end
			addEquipmentToBackpack: Void -- Put 'this' Equipment in your backpack!
				-> equipment: EQUIPMENT
				require
					spaceInBackpack > 0;
				ensure
					spaceInBackpack = old spaceInBackpack + 1;
			end 
		invariant
			otherItemsEquipped.length <= 2;
			potionsEquipped.length <= 3;
			-- An Inventory can only have weapons or shields in max the number of hands he has
			spaceInBackpack >= 0 and spaceInBackpack <= 3;
			spaceInBackpack = 3 - equipmentInBackpack.length;
	end
	
	class EQUIPMENT -- Equipment can be worn by the hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			tapped BOOLEAN -- Are you tapped right now?
			
			name: STRING -- What is your name?
			equipmentType: WEAPON_TYPE -- What type of equipment are you?
			buyPrice: INTEGER -- What is your price?
			abilities: SEQUENCE[ABILITY] -- What are your abilities?
			handsToWield: INTEGER -- How many hands do you use?
		invariant
			-- "An equipment may only be tapped one time per round"
			true;
	end
		
	class TRAINING_TOKEN -- A token that give extra dice in a specific kind of attack
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			type: ATTACK_TYPE -- What attack do you grant bonus to?
	end
	
	class POTION -- A potion, that can either be on a square, or equipped on a Hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		inherit
			EQUIPMENT
		feature
			type POTION_TYPE -- What kind of potion are you?
	end
end

static_diagram FORMAL_OVERLORD_STUFF
component
	class OVERLORD_CARD
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			name STRING -- What is your name? Your name is 'this'!
			cardDescription STRING -- What is your description? Your description is 'this'!
			type OVERLORD_CARD_TYPE -- What type of overlord card are you?"
			abilities: SEQUENCE[ABILITY] -- What abilities do you have?
	end
end

static_diagram FORMAL_EVENT_CLUSTER
component
	class ABILITY -- Can this ability be used now?
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			canBeUsedNow: BOOLEAN -- Can this ability be used now?
				-> GAME_STATE
			end
	end
end

static_diagram FORMAL_BOARD_CLUSTER
component
	class BOARD -- The entire gameboard, made up of squares
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "02-12-2011";
		feature
			width: INTEGER -- What is your width?
			height: INTEGER -- What is your height?
			heroesInTown; SEQUENCE[HERO] -- What heroes are currently in town?
			withinBoard: BOOLEAN -- Is the coordinate (x/y) within the board?
				-> coord: POINT
				require 
					coord =/ Void;
				ensure
					Result = coord.x >= 0 and coord.x < width \
					\and coord.y >= 0 and coord.y < height;
			end
			canOverlordSpawn: BOOLEAN -- Can the overlord spawn here?
				-> coord: POINT
				require
					withinBoard(coord.x, coord.y);
					coord =/ Void;
					
			end
			canMoveTo: BOOLEAN -- Is this square pass-/movable?
				-> coord: POINT
				require
					withinBoard(coord.x, coord.y);
					coord /= Void;
			end
			lineOfSight: BOOLEAN -- Is there line of sight from 'here' to 'there'?
				-> here: POINT
				-> there: POINT
				-> monstersBlock: BOOLEAN -- not included monsters?
				require
					here =/ Void;
					there =/ Void;
			end
			spaceVisiblyByPlayers: BOOLEAN -- Is this space visible by players?
	end
	
	class SQUARE -- A single square of the board
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			marker: MARKER -- What marker is on this square?
			figure: FIGURE -- What figure is on this square?
	end
	
	class TOWN -- When in town the players can buy, they also go there when they die
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			heroesInTown: SEQUENCE[HERO] -- What heroes are in town right now
	end
end

static_diagram FORMAL_STATE_STUFF
component
	class STATE_MANAGER
		indexing 
			author: "Martin Marcher";
		feature
			GetInstance: STATE_MANAGER -- Can I have the unique object of this class?
			CurrentState: STATE -- What is the current state?
			PreviousStates: SEQUENCE[STATE] -- What was the previous 'n' states?
				-> count: INTEGER
				require
					count > 0;
				ensure
					Result.length <= count;
			end
			NextPossibleStates: SEQUENCE[STATE] -- What are the next possible states?
	end
	class STATE_MACHINE
		indexing
			author: "Martin Marcher";
		feature
			CurrentState: STATE -- What is the current state?
			NextState: STATE -- What is the next state?
			PreviousStates: SEQUENCE[STATE] -- What was the previous 'n' states?
				-> count: INTEGER
				require
					count > 0;
				ensure
					Result.length <= count;
			end
			ChangeToNextState: Void -- Change to next state!
			PlaceStates: Void -- Place these states after the current state
				-> states: SEQUENCE[STATE]
				require
					states /= Void and states.Length > 0;
				ensure
					NextState = states.First;
			end
			invariant
				CurrentState /= Void;
				NextState /= Void;
	end
end