static_diagram FORMEL_PLAYER
component
	class PLAYER -- The actual player, playing the game
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			connection: CONNECTION -- What is your connection?
			isOverlord: BOOLEAN -- What is your role?
			isServer: BOOLEAN -- Are you client or server?
			uniqueID: INTEGER -- What is your unique player ID?
			setUniqueID: Void -- Your unique player ID is this!
				-> id: INTEGER
				ensure
					uniqueID = id;
			end
	end
			
	class HERO_PARTY -- A party of heroes
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "12-12-2011";
		feature
			heroes: MAP[int, Hero] -- What heroes is in the party?
			playerIds: SEQUENCE[int] -- What are the id's for all players?
			runeKeys: SET[Color] -- What color of rune keys do the heroes have?
			numberOfHeroes: INTEGER -- How many players are in the HeroParty?
			allHeroes: SEQUENCE[HERO] -- All heroes playing the game?
			conquestTokens: INTEGER -- How many conquest tokens do the players have?
			isConquestPoolEmpty: BOOLEAN -- How many conquest tokens do the players have?
				ensure
					Result -> conquestTokens = 0;
			end
			removeConquestTokens: Void -- Remove 'this' number of conquest tokens from the pool of tokens!
				-> tokens: INTEGER
				require
					tokens > 0;
				ensure
					conquestTokens = old conquestTokens - tokens or conquestTokens = 0;
			end
			addConquestTokens: Void -- Add 'this' number of conquest tokens to the pool of tokens!
				-> tokens: INTEGER
				require
					tokens > 0;
				ensure
					conquestTokens = old conquestTokens + tokens;
			end
			addHero: Void -- Add 'this' hero to the list of heroes in the HeroParty!
				-> id: INTEGER
				-> hero: Hero
				require
					hero /= Void;
			end
            addRuneKey -- Add 'this' rune key!
                -> runeKey: RUNE_KEY
                ensure
                    hasRuneKey(runeKey);
            end
            hasRuneKey: BOOLEAN -- Do you have this rune key?
                -> runeKey: RUNE_KEY
			getPlayerId: INTEGER -- Get the player id of the player that has 'this' hero
				-> hero: Hero
	end
	
	class OVERLORD -- The role of a overlord, that a hero can be
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "30-11-2011";
		feature
			overlordCardsInHand: SEQUENCE[OVERLORD_CARD] -- What cards do you have?
				ensure
					Result.length = numberOfOverlordCardsInHand;
			end
			overlordCardsInDeck: SEQUENCE[OVERLORD_CARD] -- What cards are in your library?
			overlordCardsInGraveyard: INTEGER -- How many cards are in your overlord graveyard?
			overlordPowers: SEQUENCE[OVERLORD_CARD] -- What overlord powers do you have in play?
			threatTokens: INTEGER -- How many threat tokens do you have?
	end	
	
	class FIGURE
		indexing
			author: "Jonas Breindahl";
			created: "28-11-2011";
			revised: "12-12-2011";
		feature
			uniqueID: INTEGER -- What is your unique figure ID?
			name: STRING -- What is your name?
			width: INTEGER -- How wide are you?
			height: INTEGER -- How high are you?
			orientation: Orientation -- Are you horizontal or vertical?
			maxHealth: INTEGER -- What is your max health?
			health: INTEGER -- What is your health right now?
			armor: INTEGER -- What is your armor?
			speed: INTEGER -- What is your speed?
			movementLeft: INTEGER -- How much speed do you have left?
			attacksLeft: INTEGER -- How many attacks do you have left?
			attackType: AttackType -- What kind of attack type do you attack with
			diceForAttacks: SEQUENCE[DICE] -- What dice do you use to attack?
			abilities: SEQUENCE[ABILITY] -- What abilities do you have?
			surgeAbilities: SEQUENCE[SURGE_ABILITY] -- What surge abilities do you have?
			effects: SEQUENCE[EFFECT] -- What effect are on you?
			texture: Texture -- How are you drawn?
			addHealth: Void -- Add 'this' amount of health!
				-> INTEGER: healthAmount
				require
					healthAmount > 0;
				ensure
					old health + healthAmount > maxHealth -> health = maxHealth;
					old health + healthAmount <= maxHealth -> health = old health + healthAmount;
			end
			removeHealth: Void -- Lose 'this' amount of health!
				-> INTEGER: healthAmount
				require
					healthAmount > 0;
				ensure
					old health - healthAmount < 0 -> health = 0;
					old health - healthAmount >= 0 -> health = old health - healthAmount;
			end
			setMovementLeft: Void -- Set movement left to 'this'
				-> amount: INTEGER
				require
					amount >= 0;
				ensure
					movementLeft = amount;
			end
			addMovement: Void -- Add 'this' amount of speed!
				-> INTEGER: speedAmount
				require
					speedAmount > 0;
				ensure 
					speed = old speed + speedAmount;
			end
			removeMovement: Void -- Lose 'this' amount of speed!
				-> INTEGER: speedAmount
				require
					speedAmount > 0;
					speedAmount <= movementLeft;
				ensure
					movementLeft = old movementLeft - speedAmount;
			end
			setAttacks: Void -- Set the number of attacks to 'this'
				-> amount: INTEGER
				require
					amount >= 0;
				ensure
					attacksLeft >= amount;
			end
			addAttack: Void -- Increase the number of attacks by one
				ensure
					attacksLeft = old attacksLeft + 1;
			end
			removeAttack: Void -- Decrease the number of attacks by one
				ensure
					attacksLeft = old attacksLeft - 1;
			end
			addAbility: Void -- Add 'this' ability to the list of abilities
				-> ability: Ability
				require
					ability /= Void;
				ensure
					abilities.length = old abilities.length + 1
			end
			getAttack: Attack -- Can I have an attack, as you would make one right now?
		invariant
			name.length > 0;
			maxHealth > 0;
			health >= 0 and health <= maxHealth;
			speed > 0;
			armor >= 0;
			speedLeft >= 0;
			attacksLeft >= 0;
	end
	
	class HERO
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		inherit
			FIGURE
		feature
			maxFatique: INTEGER -- What is your max fatique?
			fatique: INTEGER -- What is your fatique right now?
			cost: INTEGER -- How many conquest tokens do you cost?
			hands: INTEGER -- How many hands do you have?
			coins: INTEGER -- How many coins do you have?
			inventory: Inventory -- What is your inventory?
			bigTexture: Texture -- What is your big texture?
			trainingTokens: INTEGER -- How many training tokens do you have in MELEE/RANGED/MAGIC?
				-> attackType: AttackType
			addFatique: Void -- Add 'this' amount of fatique!
				-> fatiqueAmount: INTEGER
				require
					fatiqueAmount > 0;
				ensure
					old fatique + fatiqueAmount > maxFatique -> fatique = maxFatique;
					old fatique + fatiqueAmount <= maxFatique -> fatique = old fatique + fatiqueAmount;
			end
			removeFatique: Void -- Lose 'this' amount of fatique!
				-> fatiqueAmount: INTEGER
				require
					fatiqueAmount > 0;
					fatigueAmount <= fatigue;
				ensure
					old fatique + fatiqueAmount < 0 -> fatique = 0;
					old fatique + fatiqueAmount >= 0 -> fatique = old fatique + fatiqueAmount;
			end
			addSkill: Void -- Add 'this' skill to your list of skills 
				-> skill: Skill
			removeSkill: Void -- Remove 'this' skill from your list of skills
				-> skill: Skill
			untapAll: Void -- Untap all cards!
			endTurn: Void -- Reset movement left and attacks left!
		invariant
			fatique <= maxFatique;
			fatique > 0;
	end
	
	class MONSTER -- A monster, controlled by the overlord
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "02-12-2011";
		inherit
			FIGURE
		feature
			isMaster: BOOLEAN -- Are you are you a master monster?
			clone: Monster -- Give me a clone of you!
				-> newID: INTEGER
	end
end

static_diagram FORMAL_HERO_STUFF
component
	class SKILL -- The skill-cards of a hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "12-12-2011";
		feature
			id: INTEGER -- What is your unique id?
			name: STRING -- What is your name?
			skillType: ATTACK_TYPE -- What type of skill are you?
			skillDescription: STRING -- What is your description?
			abilities: SEQUENCE[ABILITY] -- What are your abilities?
			tapped: BOOLEAN -- Are you tapped right now?
	end
	
	class INVENTORY
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "12-12-2011";
		feature
			atIndex: EQUIPMENT -- What is in 'this' slot?
				-> index: INTEGER
			length: INTEGER -- How many slots do you have?
			maxHands: INTEGER -- How many hands do you have?
			freeHands: INTEGER -- How many hands do you have free?
            weaponEquipped: EQUIPMENT -- What weapons do you have in your hands?
			shieldEquipped: EQUIPMENT -- What shield do you have equipped?
			armorEquipped: EQUIPMENT -- What armor do you have equipped?
			otherItemsEquipped: SEQUENCE[EQUIPMENT] -- What other items do you have equipped?
			potionsEquipped: SEQUENCE[EQUIPMENT] -- What potions do you have equipped?
			equipmentInBackpack: SEQUENCE[EQUIPMENT] -- What equipment do you have in your backpack?
            maxPotions: INTEGER -- How many potions can you hold?
            maxInBackpack: INTEGER -- How many items can you hold in your backpack?
            maxOtherItems: INTEGER -- How many other items can you hold?
			canEquipWeapon: BOOLEAN -- Can you equip 'this' weapon?
				-> equipment: EQUIPMENT
			canEquipPotion: BOOLEAN -- Can you equip a potion right now?
			equipWeapon: Void -- Equip 'this' weapon!
				-> weapon: EQUIPMENT
				require
                    weapon /= Void;
					freeHands <= weapon.hands();
					weapon.type = Weapon;
				ensure
					weaponEquipped = weapon;
                    freeHands = old freeHands - weapon.hands();
			end
			equipArmor: Void -- Equip 'this' armor!
				-> armor: EQUIPMENT
				require
					armor /= Void;
				ensure
					armorEquipped = armor;
			end
			equipShield: Void -- Equip 'this' armor!
				-> shield: EQUIPMENT
				require
					shield /= Void;
					freeHands <= shield.hands();
				ensure
					shieldEquipped = shield;
                    freeHands = old freeHands - shield.hands();
			end
			equipOtherItem: Void -- Equip 'this' other item!
                -> index: INTEGER
				-> item: EQUIPMENT
				require
					otherItemsEquipped.length < 3;
				ensure
					otherItemsEquipped.length = old otherItemsEquipped.length + 1;
			end
			equipPotion: Void -- Equip 'this' potion!
                -> index: INTEGER
				-> potion: EQUIPMENT
				require
					potionsEquipped.length < 3;
				ensure
					potionsEquipped.length = old potionsEquipped.length + 1;
			end
			addEquipmentToBackpack: Void -- Put 'this' Equipment in your backpack!
                -> index: INTEGER
				-> equipment: EQUIPMENT
				require
					equipment /= Void;
					spaceInBackpack > 0;
				ensure
					spaceInBackpack = old spaceInBackpack - 1;
			end
            unequipWeapon: EQUIPMENT -- Unequip 'this' weapon!
                require
                    weaponEquipped /= Void;
                ensure
                    Result = old weaponEquipped;
                    freeHands = old freeHands + Result.hands();
                    weaponEquipped = Void;
            end
            unequipArmor: EQUIPMENT -- Unequip 'this' armor!
                require
                    armorEquipped /= Void;
                ensure
                    Result = old armorEquipped;
                    armorEquipped = Void;
            end
            unequipShield: EQUIPMENT -- Unequip 'this' shield!
                require
                    shieldEquipped /= Void;
                ensure
                    Result = old shieldEquipped;
                    freeHands = old freeHands + Result.hands();
                    shieldEquipped = Void;
            end
            unequipOther: EQUIPMENT -- Unequip 'this' other!
                -> index: INTEGER
                require
                    0 < index and index < maxOther;
                    otherItemsEquipped.get(index) /= Void;
                ensure
                    otherItemsEquipped.get(index) = Void;
                    Result = old otherItemsEquipped.get(index);
            end
            unequipPotion: EQUIPMENT -- Unequip 'this' potion!
                -> index: INTEGER
                require
                    0 < index and index < maxPotions;
                    potionsEquipped.get(index) /= Void;
                ensure
                    potionsEquipped.get(index) = Void;
                    Result = old potionsEquipped.get(index);
            end
            unequipFromBackpack: EQUIPMENT -- Remove 'this' from your backpack!
                -> index: INTEGER
                require
                    0 < index and index < maxInBackpack;
                    backpackEquipped.get(index) /= Void;
                ensure
                    backpackEquipped.get(index) = Void;
                    Result = old backpackEquipped.get(index);
            end
			canEquipAtInde: BOOLEAN -- Can you equip 'this' weapon at 'this' index?
				-> slot: INTEGER
				-> equipment: EQUIPMENT
		invariant
            0 < freeHands and freeHands < maxHands;
	end
	
	class EQUIPMENT -- Equipment can be worn by the hero
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "12-12-2011";
		feature
			id: INTEGER -- What is your unique ID?
			tapped BOOLEAN -- Are you tapped right now?
			name: STRING -- What is your name?
			equipmentType: EQUIPMENT_TYPE -- What type of equipment are you?
			attackType: ATTACK_TYPE -- What type of attack are you?
			rarity: EQUIPMENT_RARITY -- What rarity are you?
			abilities: SEQUENCE[ABILITY] -- What are your abilities?
			surgeAbilities: SEQUENCE[SURGE_ABILITY] -- What are your surge abilities?
			hands: INTEGER -- How many hands do you take to wield
			buyPrice: INTEGER -- What is your price?
			dice: SEQUENCE[DICE] -- What dice do you give for attack?
			equipped: BOOLEAN -- Are you equipped?
			tapEquipment: Void -- Tap yourself
				require
					!tapped;
				ensure
					tapped;
			untapEquipment: Void -- Untap yourself
				ensure
					!tapped;
			equipToHero: Void -- Equip to 'this' hero!
				-> hero: Hero
				require
					!equipped;
				ensure
					equipped;
			end
			unequipFromHero: Void -- Unequip from 'this' hero!
				-> hero: Hero
				require
					equipped;
				ensure
					!equipped;
			end
			clone: Equipment -- Give me a copy of yourself
			equals: BOOLEAN -- Are you equal to 'this' object?
				-> obj: Object
	end
	
	class SURGE_ABILITY -- A surge power on a piece of equipment
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			cost: INTEGER -- How many surges do you cost?
			ability: Ability -- What ability do you grant?
		invariant
			cost >= 0;
			ability /= Void;
	end
	
	class TREASURE -- A treasure that can be in a chest
		indexing
			author: "Jonas Breindahl";
			created: "13-12-2011";
			revised: "13-12-2011";
		feature
			id: INTEGER -- What is your unique ID?
			name: STRING -- What is your name?
			rarity: EQUIPMENT_RARITY -- What is your rarity?
			equipment: EQUPMENT -- What equipment do you have?
			coins: INTEGEr -- How many coins do you have?
			isTreasureCache: BOOLEAN -- Are you a treasure cache?
		invariant
			coins >= 0;
			equipment = Void -> isTreasureCache
	end
end

static_diagram FORMAL_OVERLORD_STUFF
component
	class OVERLORD_CARD
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			id: INTEGER -- What is your unique id?
			name: STRING -- What is your name? Your name is 'this'!
			cardDescription: STRING -- What is your description? Your description is 'this'!
			type: OVERLORD_CARD_TYPE -- What type of overlord card are you?"
            playPrice: INT -- How many threat tokens does it take to play you?
            sellPrice: INT -- How many threat tokens do I get selling you?
			deferred playCard: Void -- Play this card
			canPlay: BOOLEAN -- Can this card be played right now?
	end
    
    class SPAWN_CARD
        indexing
            author: "Martin Marcher";
        inherit
            OVERLORD_CARD
        feature
            monstersToSpawn: SEQUENCE[MONSTER] -- Can I have a list of all monsters that can be spawned with this card?
			effective playCard: Void -- Let the overlord spawn the list of monsters that are on the card
    end
end

static_diagram FORMAL_EVENT_CLUSTER
component
	class ABILITY
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			triggered: BOOLEAN -- Are you triggered or not?
			canBeUsedNow: BOOLEAN -- Can this ability be used now?
			toString: STRING -- Can I have you as a string?			
	end
	
	class ATTACK
		indexing
			author: "Jonas Breindahl";
			created: "13-12-2011";
			revised: "12-13-2011";
		feature
			attackingFigure: Figure -- What figure is attacking?
			targetSquare: Point -- What point on the board is attacked?
			rangeNeeded: INTEGER -- What range is needed to reach the target
			damageBonus: INTEGER -- What is the bonus to damage for the attack?
			rangeBonus: INTEGER -- What is the bonus to range for the attack?
			pierceBonus: INTEGER -- What is the bonus to pierce for the attack?
			surgeBonus: INTEGER -- What is the bonus to surge for the attack?
			totalDamage: INTEGER -- What is the total damage for the attack?
			totalRange: INTEGER -- What is the total range for the attack?
			totalPierce: INTEGER -- What is the total pierce for the attack?
			totalSurge: INTEGER -- What is the total surge for the attack?
			usedSurges: INTEGER -- How many surges have already been used?
			dice: SEQUENCE[DICE] -- What dice is used for the attack?
			surgeAbilities: SEQUENCE[SURGE_ABILITY] -- What surgeabilities are able for the attack?
			missed: BOOLEAN -- Is the attack missed?
			toString: STRING -- What is this attack as a string?
			setSides: Void -- Set all sides of all dice to 'these' specific sides!
				-> diceSides: SEQUENCE[INTEGER]
				require
					dice.length = diceSides.length;
			end
			rollDice: Void -- Roll all dice!
	end
end

static_diagram FORMAL_BOARD_CLUSTER
component
	class BOARD -- The entire gameboard, made up of squares
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "13-12-2011";
		feature
            get: SQUARE -- Can I have the square object for this coordinate?
                -> x: INTEGER
                -> y: INTEGER
			width: INTEGER -- What is your width?
			height: INTEGER -- What is your height?
			heroesInTown: SEQUENCE[HERO] -- What heroes are currently in town?
			figuresOnBoard: MAP[HERO, POINT] -- Where are the heroes on the board?
			texture: Texture -- What is the floor texture of the board?
			allDoors: SEQUENCE[DOOR] -- Where are all the doors on the map?
			relevantDoors: SEQUENCE[DOOR] -- Where are all the relevant doors on the map?
            withinBoard: BOOLEAN -- Is the coordinate (x/y) within the board?
				-> coord: POINT
				require 
					coord /= Void;
				ensure
					Result = coord.x >= 0 and coord.x < width 
					and coord.y >= 0 and coord.y < height;
			end
			allWithinBoard: BOOLEAN -- Are all these coordinates within the board?
				-> points: SEQUENCE[POINT]
				require
					points /= Void;
				ensure
					Result = for_all point : Point such_that points.contains(point) it_holds withinBoard(point)
			end
			canOverlordSpawn: BOOLEAN -- Can the overlord spawn here?
				-> coord: POINT
				require
					coord /= Void;
			end
			validStartPoint: BOOLEAN -- Is this square next to a glyph?
			lineOfSight: BOOLEAN -- Is there line of sight from 'here' to 'there'?
				-> here: POINT
				-> there: POINT
				-> monstersBlock: BOOLEAN -- not included monsters?
				require
					here /= Void;
					there /= Void;
			end
			lineOfSight: BOOLEAN -- Is there line of sight from 'this' figure to 'that' figure?
				-> this: Figure
				-> that: Figure
				-> monstersBlock: BOOLEAN -- not included monsters?
				require
					this /= Void;
					that /= Void;
			end
			squareVisiblyByPlayers: BOOLEAN -- Is this space visible by players?
            distance: INTEGER -- What is the distance between these squares?
                -> here: POINT
                -> there: POINT
				require
					here /= Void;
					there /= Void;
			end
			doorNextToPoint: Door -- what door, if there is one, is at 'this' point?
				-> point: Point
				require
					point /= Void;
			end
			canDoorBeOpend: BOOLEAN -- Can a door be opened at 'this' point?
				-> point: Point
				require
					point /= Void;
			end
            openDoor: Void -- Open the door adjecent to this square!
                -> point: POINT
				require
					point /= Void;
            end
			squaresForFigure: SEQUENCE[POINT] -- Can I have a list of points where 'this' figure is standing?
				-> figure: Figure
				require
					figure /= Void;
				ensure
					Result.length > 1;
			end
			canFigureMoveToPoint: BOOLEAN -- Can 'this' figure move to 'this' point?
				-> figure: Figure
				-> point: Point
				require
					figure /= Void;
					point /= Void;
			end
			standable: BOOLEAN -- Is this square standable?
				-> coord: POINT
				require
					withinBoard(coord.x, coord.y);
					coord /= Void;
			end
			visibleSquare: BOOLEAN -- Is this square visible by players?
			addDoor: Void -- Add 'this' door to the map!
				-> door: Door;
				require
					door /= Void;
			end
			openDoor: Void -- Open the door adjacent to this square
				-> point: Point
				require 
					canDoorBeOpend(point);
			end
			moveFigure: Void -- Move 'this' figure to 'that' square on the bord
				-> figure: Figure
				-> point Point
				require
					figure /= Void;
					point /= Void;
					canFigureMoveToPoint(figure, point);
				ensure
					figuresOnBoard[figure] = point;
			end
			placeFigure: Void -- Place 'this' figure at 'this' square on the board
				-> figure: Figure
				-> point: Point
				require
					figure /= Void;
					point /= Void;
				ensure
					figuresOnBoard[figure] = point;
			end
			removeFigure: Void -- Remove the figure at 'this' point from the board!
				-> point: Point
				require
					point /= Void;
					get(point.X, point.Y).Figure /= Void;
			end
	end
	
	class SQUARE -- A single square of the board
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "13-12-2011";
		feature
			area: INTEGER -- What area is this square in?
			marker: MARKER -- What marker is on this square?
			figure: FIGURE -- What figure is on this square?
	end
	
	class TOWN -- When in town the players can buy, they also go there when they die
		indexing
			author: "Jonas Breindahl";
			created: "30-11-2011";
			revised: "30-11-2011";
		feature
			heroesInTown: SEQUENCE[HERO] -- What heroes are in town right now
	end
end

static_diagram BOARD_MARKER_CLUSTER
component
	class
		indexing
			author: "Jonas Breindahl";
			created: "13-12-2011";
			revised: "13-12-2011";
		feature
			id: INTEGER -- What is your unique id?
			name: STRING -- What is your name?
			texture: Texture -- How are you drawn?
			movementPoints: INTEGER -- How many movement points does it cost to interact with the marker?
			puckUp: Void -- Pick up, or interact with the marker!
		invariant
			movementPoints >= 0;
	end
end

static_diagram FORMAL_STATE_STUFF
component
    class GAME_STATE
        indexing
            author: "Simon Henriksen & Martin Marcher";
        feature
            allEquipment: SEQUENCE[EQUIPMENT] -- Show me all your equipment
            canBuyEquipment: BOOLEAN -- Can I buy 'this' equipment?
                -> equipment: EQUIPMENT
                require
                    allEquipment /= Void;
                ensure
                    Result -> allEquipment.contains(equipment);
            end
            getOverlordCards: SEQUENCE[OVERLORD_CARD] -- Give me 'n' Overlord Cards.
                -> count: INTEGER
                require
                    count > 0;
                ensure
                    Result.length = count;
            end
            getHero: HERO -- Give me a Hero.
            getChestContents: SEQUENCE[INTEGER] -- What is in 'this' chest?
                -> chestId: INTEGER
                ensure
                    Result.length = 4;
            end
            getTreasure: TREASURE -- Give me 'this kind' of treasure.
                -> type: TREASURE_TYPE
                ensure
                    Result.type = type;
            end
            unequippedEquipment: SEQUENCE[EQUIPMENT] -- What has 'this Hero' not equipped?
                -> hero: HERO
            removeEquipment -- Remove 'this' equipment!
                -> equipment: EQUIPMENT
                require
                    equipment /= Void;
                    allEquipment.contains(equipment)
                ensure
                    not allEquipment.contains(equipment)
            end
            removeOverlordCards -- Remove 'these' Overlord Cards!
                -> cards: SEQUENCE[OVERLORD_CARD]
                require
                    cards.length > 0;
            end
            removeHero -- Remove 'this' Hero!
                -> hero: HERO
                require
                    hero /= Void;
            end
            removeTreasure -- Remove 'this' treasure card!
                -> treasure: TREASURE
                require
                    treasure /= Void;
            end
            unequipEquipment -- 'This Hero' unequipped 'this Equipment'!
                -> hero: HERO
                -> equipment: EQUIPMENT
                require
                    hero /= Void;
                    equipment /= Void;
                ensure
                    not unequippedEquipment(hero).contains(equipment);
            end
    end
	class STATE_MANAGER
		indexing 
			author: "Martin Marcher";
		feature
			GetInstance: STATE_MANAGER -- Can I have the unique object of this class?
			CurrentState: STATE -- What is the current state?
			PreviousStates: SEQUENCE[STATE] -- What was the previous 'n' states?
				-> count: INTEGER
				require
					count > 0;
				ensure
					Result.length <= count;
			end
			NextPossibleStates: SEQUENCE[STATE] -- What are the next possible states?
	end
	class STATE_MACHINE
		indexing
			author: "Martin Marcher";
		feature
			CurrentState: STATE -- What is the current state?
			NextState: STATE -- What is the next state?
			PreviousStates: SEQUENCE[STATE] -- What was the previous 'n' states?
				-> count: INTEGER
				require
					count > 0;
				ensure
					Result.length <= count;
			end
			ChangeToNextState: Void -- Change to next state!
			PlaceStates: Void -- Place these states after the current state
				-> states: SEQUENCE[STATE]
				require
					states /= Void and states.Length > 0;
				ensure
					NextState = states.First;
			end
			invariant
				CurrentState /= Void;
				NextState /= Void;
	end
end

static_diagram FORMEL_GUI
component
	class DRAWABLE
		indexing
			author: "Emil Juul Jacobsen";
			created: "13-12-2011";
			revised: "13-12-2011";
		feature
			getTexture: TEXTURE2D
			setTexture
				-> newTexture: TEXTURE2D
				require
					newTexture /= Void;
				ensure
					getTexture() = newTexture;
			end
	end
	
	class GUI
		indexing
			author: "Emil Juul Jacobsen";
			created: "13-12-2011";
			revised: "13-12-2011";
		feature
			getFont: SPRITEFONT
			setFont
				-> newFont: SPRITEFONT
				require
					newFont /= Void;
				ensure
					getFont() = newFont;
			end
			update
				-> gametime: GAMETIME -- XNA method
			changeStateGUI
				-> stateGUI: GUI_ELEMENT
			initiateBoardGUI
				-> board: BOARD
				-> role: ROLE
			initiateMenuGUI
				-> role: ROLE
			markSquare
				-> x: INTEGER
				-> y: INTEGER
				-> positive: BOOLEAN
			clearMarks
	end
	
	class GUI_ELEMENT
		indexing
			author: "Emil Juul Jacobsen";
			created: "13-12-2011";
			revised: "13-12-2011";
		feature
			getBounds: RECTANGLE
			hasPoint: BOOLEAN
				-> x: INTEGER
				-> y: INTEGER
			hasFocus: BOOLEAN
			getName: STRING
			drawsBackground: BOOLEAN
			loseFocus
				ensure
					not hasFocus();
			end
			getFont: SPRITEFONT
				ensure
					Result /= Void;
			end
			setFont
				-> newFont: SPRITEFONT
				ensure
					getFont() = newFont;
			end
			move
				-> x: INTEGER
				-> y: INTEGER
			disable
				ensure
					not drawsBackground();
			end
			handleClick: BOOLEAN
				-> x: INTEGER
				-> y: INTEGER
			handleKeyPress
				-> key: KEYS
			setClickAction
				-> target: STRING
				-> effect: ACTION
				require
					target /= Void;
			end
			addChild
				-> child: GUI_ELEMENT
				require
					child /= Void;
			end
			clearChildren
			addDrawableV
				-> target: STRING
				-> visual: DRAWABLE
				-> position: VECTOR2
				require
					target /= Void;
					visual /= Void;
					position /= Void;
			end
			addDrawableR
				-> target: STRING
				-> visual: DRAWABLE
				-> position: RECTANGLE
				require
					target /= Void;
					visual /= Void;
					position /= Void;
			end
			addText
				-> target: STRING
				-> text: STRING
				-> position: VECTOR2
				require
					target /= Void;
					text /= Void;
					position /= Void;
			end
			addTextC
				-> target: STRING
				-> text: STRING
				-> position: VECTOR2
				-> color: COLOR
				require
					target /= Void;
					text /= Void;
					position /= Void;
					color /= Void;
			end
			setDrawBackground
				-> toDraw: BOOLEAN
				ensure
					toDraw = drawsBackground();
			end
			setBackground
				-> newBG: STRING
				ensure
					drawsBackground;
			end
			draw
				-> spriteBatch: SPRITEBATCH
			update
				-> gametime: GAMETIME
	end
	
	class GUI_ELEMENT_FACTORY
		indexing
			author: "Emil Juul Jacobsen";
			created: "13-12-2011";
			revised: "13-12-2011";
		feature
			createBoardElement: GUI_ELEMENT
				-> game: GAME
				-> board: BOARD
				-> role: ROLE
				require
					game /= Void;
					board /= Void;
					role /= Void;
			end
			createStateElement: GUI_ELEMENT
				-> game: GAME
				-> state: STATE
				-> role: ROLE
				-> gamestate: GAMESTATE
				require
					game /= Void;
					board /= Void;
					role /= Void;
			end
			createMenuElement: GUI_ELEMENT
				-> game: GAME
				-> role: ROLE
				require
					game /= Void;
					role /= Void;
			end
			createEquipmentElement: EQUIPMENT_ELEMENT
				-> game: GAME
				-> x: INTEGER
				-> y: INTEGER
				-> slotName: STRING
				-> equipment: EQUIPMENT
				-> id: INTEGER
				require
					game /= Void;
				ensure
					Result.getId() = id;
					Result.getEquipment() = equipment;
			end
			drawSurgeAbility
				-> target: GUI_ELEMENT
				-> ability: SURGE_ABILITY
				-> x: INTEGER
				-> y: INTEGER
				-> small: BOOLEAN
				require
					target /= Void;
					ability /= Void;
					target.hasPoint(x,y);
			end
			drawDice
				-> target: GUI_ELEMENT
				-> dice: DICE
				-> x: INTEGER
				-> y: INTEGER
				-> size: INTEGER
				require
					target /= Void;
					dice /= Void;
					target.hasPoint(x,y);
					size > 0;
			end
	end
	
end
	
	
	
	
	
	
	
	
	
	
	
	
