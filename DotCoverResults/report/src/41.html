<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_41 = [
  ];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src41" class="dotCoverSource"><pre>using Descent.GUI.Screens;

namespace Descent.GUI
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;
    using Descent.GUI.SubElements;
    using Descent.Model;
    using Descent.Model.Board;
    using Descent.Model.Player;
    using Descent.Model.Player.Figure.HeroStuff;
    using Descent.State;
    using Microsoft.Xna.Framework;
    using Microsoft.Xna.Framework.Graphics;

    /// &lt;summary&gt;
    /// Responsible for creating the GUIElements for the different layers of the gui and
    /// for all the different states and roles in the game. This is done as a simple hierarchy
    /// of GUIElements and should be populated with logic (events on click) and Drawables to
    /// be displayed within the respective GUIElements in the tree.
    /// &lt;/summary&gt;
    /// &lt;author&gt;
    /// Emil Juul Jacobsen
    /// &lt;/author&gt;
    public class GUIElementFactory
    {
        private static Dictionary&lt;EDice, Texture2D&gt; dicetinary;

        private static GUIElement CreateEmptyRoot(Game game)
        {
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.X == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Y == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Width == game.GraphicsDevice.Viewport.Width);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Height == game.GraphicsDevice.Viewport.Height);

            GUIElement result = new GUIElement(game, &quot;root&quot;, 0, 0, game.GraphicsDevice.Viewport.Width, game.GraphicsDevice.Viewport.Height);
            result.SetDrawBackground(false);

            return result;
        }

        private static int RelW(Viewport viewport, int percentage)
        {
            return (int)(viewport.Width * (3.0 / 4.0) * (percentage / 100.0));
        }

        private static int RelH(Viewport viewport, int percentage)
        {
            return (int)(viewport.Height * (percentage / 100.0));
        }

        // public

        /// &lt;summary&gt;
        /// Creates a guielement that displays how the board looks like and keeps updated when
        /// the board changes.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The current Game object.&lt;/param&gt;
        /// &lt;param name=&quot;board&quot;&gt;The Board to visualize.&lt;/param&gt;
        /// &lt;param name=&quot;role&quot;&gt;The Role to view the board from, for example 
        /// the overlord may see the entire board from the beginning&lt;/param&gt;
        /// &lt;returns&gt;A Guielement that displays the board.&lt;/returns&gt;
        public static GUIElement CreateBoardElement(Game game, Board board, Role role)
        {
            Contract.Requires(game != null);
            Contract.Requires(board != null);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;() != null);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.X == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Y == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Width == (int)(game.GraphicsDevice.Viewport.Width * (3 / 4.0)));
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Height == game.GraphicsDevice.Viewport.Height);

            return new BoardElement(game, board, role);
        }

        /// &lt;summary&gt;
        /// Creates a GUIElement that fits the given parameters.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The current Game object.&lt;/param&gt;
        /// &lt;param name=&quot;state&quot;&gt;The State to be visualized.&lt;/param&gt;
        /// &lt;param name=&quot;role&quot;&gt;The Role to view the given state from.&lt;/param&gt;
        /// &lt;param name=&quot;gameState&quot;&gt;An object that holds some game properties that is needed for some States.&lt;/param&gt;
        /// &lt;returns&gt;A new GUIElement that visualizes the given State.&lt;/returns&gt;
        public static GUIElement CreateStateElement(Game game, State state, Role role, GameState gameState)
        {
            Contract.Requires(game != null);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;() != null);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.X == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Y == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Width == game.GraphicsDevice.Viewport.Width);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Height == game.GraphicsDevice.Viewport.Height);

            Viewport g = game.GraphicsDevice.Viewport;

            GUIElement root = CreateEmptyRoot(game);

            switch (state)
            {
                // TODO: fill the root here for all states that is drawn
                case State.InLobby:
                    {
                        GUIElement box = new GUIElement(game, &quot;players&quot;, RelW(g, 10), RelH(g, 10), RelW(g, 80), RelH(g, 80));
                        GUIElement p1 = new GUIElement(game, &quot;player1&quot;, RelW(g, 40), RelH(g, 15), RelW(g, 20), RelH(g, 20));
                        GUIElement p2 = new GUIElement(game, &quot;player2&quot;, RelW(g, 23), RelH(g, 40), RelW(g, 20), RelH(g, 20));
                        GUIElement p3 = new GUIElement(game, &quot;player3&quot;, RelW(g, 56), RelH(g, 40), RelW(g, 20), RelH(g, 20));
                        GUIElement p4 = new GUIElement(game, &quot;player4&quot;, RelW(g, 23), RelH(g, 65), RelW(g, 20), RelH(g, 20));
                        GUIElement p5 = new GUIElement(game, &quot;player5&quot;, RelW(g, 56), RelH(g, 65), RelW(g, 20), RelH(g, 20));

                        root.AddChild(box);
                        box.AddChild(p1);
                        box.AddChild(p2);
                        box.AddChild(p3);
                        box.AddChild(p4);
                        box.AddChild(p5);

                        Vector2 pos = new Vector2(10, 15);
                        root.AddText(&quot;player1&quot;, &quot;Overlord:&quot;, pos);
                        root.AddText(&quot;player2&quot;, &quot;Hero:&quot;, pos);
                        root.AddText(&quot;player3&quot;, &quot;Hero:&quot;, pos);
                        root.AddText(&quot;player4&quot;, &quot;Hero:&quot;, pos);
                        root.AddText(&quot;player5&quot;, &quot;Hero:&quot;, pos);

                        if (Player.Instance.IsServer)
                        {
                            GUIElement start = new GUIElement(game, &quot;start&quot;, RelW(g, 84), RelH(g, 90), RelW(g, 12), RelH(g, 4));
                            root.AddChild(start);
                            root.AddText(&quot;start&quot;, &quot;Start Game&quot;, new Vector2(0, 0));

                            string ipString = &quot;&quot;;
                            foreach (string ip in Player.Instance.Connection.Ips) ipString += (ip + &quot;\n&quot;);
                            root.AddText(box.Name, ipString, new Vector2(10, 10));
                        }

                        break;
                    }
                case State.AllBuyEquipment:
                case State.BuyEquipment:
                    {
                        GUIElement box = new GUIElement(game, &quot;shop&quot;, RelW(g, 5), RelH(g, 5), RelW(g, 90), RelH(g, 80));

                        int startY = RelH(g, 10);
                        int startX = RelW(g, 10);

                        int spacerX = RelW(g, 2);
                        int spacerY = RelH(g, 5);

                        int width = RelW(g, 12);
                        int height = RelH(g, 16);

                        Equipment[] shopContent = gameState.CurrentEquipment.Where(n =&gt; n.Rarity == EquipmentRarity.Common).Distinct().ToArray();
                        for (int y = 0; y &lt; 4; y++)
                        {
                            for (int x = 0; x &lt; 6; x++)
                            {
                                if (shopContent.Length &gt; (x + y * 6))
                                {
                                    Equipment current = shopContent[x + y * 6];
                                    EquipmentElement eq = new EquipmentElement(game, startX + x * width + x * spacerX,
                                                                               startY + y * width + y * spacerY, width, height,
                                                                               &quot;&quot;, current, x + y * 6 + 1000);
                                    box.AddChild(eq);
                                }
                            }
                        }

                        if (role != Role.Overlord)
                        {
                            GUIElement done = new GUIElement(game, &quot;done&quot;, RelW(g, 85), RelH(g, 90), RelW(g, 10), RelH(g, 5));
                            done.AddText(done.Name, &quot;Done&quot;, new Vector2(0, 0));

                            root.AddChild(done);
                        }
                        root.AddChild(box);
                        break;
                    }
                case State.AllEquip:
                case State.Equip:
                    {

                        if (role != Role.Overlord)
                        {
                            int startX = RelW(g, 15);
                            int startY = RelH(g, 15);
                            int spacerX = RelW(g, 2);
                            int width = RelW(g, 10);

                            Equipment[] unequipped = gameState.UnequippedEquipment(Player.Instance.Id);
                            int boxes = Math.Max(1, unequipped.Length);

                            for (int x = 0; x &lt; boxes; x++)
                            {
                                Equipment current = (x &lt; unequipped.Length) ? unequipped[x] : null;
                                EquipmentElement eq = GUIElementFactory.CreateEquipmentElement(game, startX + x * width + x * spacerX, startY, &quot;&quot;, current, x + 100);
                                root.AddChild(eq);
                            }

                            GUIElement done = new GUIElement(game, &quot;done&quot;, RelW(g, 3), RelW(g, 3), RelW(g, 10), RelH(g, 5));
                            done.AddText(done.Name, &quot;Done&quot;, new Vector2(0, 0));
                            root.AddChild(done);
                        }
                        break;
                    }
                case State.WaitForChooseSquare: // hero placement
                    {
                        if (role != Role.Overlord)
                        {
                            GUIElement help = new GUIElement(game, &quot;help&quot;, RelW(g, 3), RelW(g, 3), RelW(g, 33), RelH(g, 5));

                            root.AddChild(help);
                            root.AddText(help.Name, &quot;Select a square to place your hero&quot;, new Vector2(5, 5));
                        }
                        break;
                    }
                case State.WaitForHeroTurn:
                    {
                        if (role != Role.Overlord)
                        {
                            GUIElement takeTurn = new GUIElement(game, &quot;take turn&quot;, RelW(g, 3), RelW(g, 3), RelW(g, 15), RelH(g, 5));
                            root.AddChild(takeTurn);
                            root.AddText(takeTurn.Name, &quot;Take Turn&quot;, new Vector2(5, 5));
                        }
                        break;
                    }
                case State.WaitForChooseAction:
                    {
                        if (role == Role.ActiveHero)
                        {
                            GUIElement advance = new GUIElement(game, &quot;advance&quot;, RelW(g, 3), RelH(g, 3), RelW(g, 10), RelH(g, 5));
                            GUIElement run = new GUIElement(game, &quot;run&quot;, RelW(g, 3), RelH(g, 10), RelW(g, 10), RelH(g, 5));
                            GUIElement battle = new GUIElement(game, &quot;battle&quot;, RelW(g, 3), RelH(g, 17), RelW(g, 10), RelH(g, 5));

                            Vector2 v = new Vector2(5, 5);
                            advance.AddText(advance.Name, &quot;Advance&quot;, v);
                            run.AddText(run.Name, &quot;Run&quot;, v);
                            battle.AddText(battle.Name, &quot;Battle&quot;, v);

                            root.AddChild(advance);
                            root.AddChild(run);
                            root.AddChild(battle);
                        }
                        break;
                    }
                case State.WaitForPerformAction:
                    {
                        if (role == Role.ActiveHero)
                        {
                            GUIElement end = new GUIElement(game, &quot;end&quot;, RelW(g, 3), RelW(g, 3), RelW(g, 15), RelH(g, 5));

                            root.AddChild(end);
                            root.AddText(end.Name, &quot;End Turn&quot;, new Vector2(5, 5));
                        }
                        else if (role == Role.Overlord &amp;&amp; Player.Instance.StateManager.HasTurn())
                        {
                            GUIElement end = new GUIElement(game, &quot;end&quot;, RelW(g, 3), RelW(g, 3), RelW(g, 15), RelH(g, 8));
                            root.AddChild(end);
                            root.AddText(end.Name, &quot;End Monster Turn&quot;, new Vector2(5, 5));
                        }
                        break;
                    }
                case State.WaitForOverlordChooseAction:
                    {
                        if (role == Role.Overlord)
                        {
                            GUIElement end = new GUIElement(game, &quot;end&quot;, RelW(g, 3), RelW(g, 3), RelW(g, 15), RelH(g, 8));

                            root.AddChild(end);
                            root.AddText(end.Name, &quot;End Overlord Turn&quot;, new Vector2(5, 5));
                        }
                        break;
                    }
                case State.WaitForRollDice:
                    {
                        GUIElement box = new GUIElement(game, &quot;box&quot;, RelW(g, 10), RelH(g, 10), RelW(g, 80), RelH(g, 60));
                        if (gameState.CurrentPlayer == Player.Instance.Id)
                        {
                            GUIElement roll = new GUIElement(game, &quot;roll&quot;, RelW(g, 75), RelH(g, 70), RelW(g, 10), RelH(g, 6));
                            root.AddChild(roll);
                            root.AddText(roll.Name, &quot;Roll&quot;, new Vector2(5, 5));
                        }
                        root.AddChild(box);

                        break;
                    }
                case State.WaitForDiceChoice:
                    {
                        GUIElement box = new AttackElement(game, gameState.CurrentAttack, RelW(g, 10), RelH(g, 10), RelW(g, 80), RelH(g, 60));

                        if (gameState.CurrentPlayer == Player.Instance.Id)
                        {
                            GUIElement finish = new GUIElement(game, &quot;finish&quot;, RelW(g, 75), RelH(g, 70), RelW(g, 10), RelH(g, 8));
                            root.AddChild(finish);
                            root.AddText(finish.Name, &quot;Inflict Wounds&quot;, new Vector2(5, 5));
                        }
                        root.AddChild(box);

                        break;
                    }
                case State.EndGameHeroParty:
                    {
                        GUIElement box = new GUIElement(game, &quot;box&quot;, RelW(g, 10), RelH(g, 10), RelW(g, 80), RelH(g, 60));
                        GUIElement inner = new GUIElement(game, &quot;inner&quot;, RelW(g, 30), RelH(g, 20), RelW(g, 40), RelH(g, 60));
                        box.AddChild(inner);
                        inner.AddText(inner.Name, &quot;The heroes have triumphed over Joe and won the game!&quot;, new Vector2(5, 5));
                        inner.SetDrawBackground(false);

                        root.AddChild(box);
                        break;
                    }
                case State.EndGameOverlord:
                    {
                        GUIElement box = new GUIElement(game, &quot;box&quot;, RelW(g, 10), RelH(g, 10), RelW(g, 80), RelH(g, 60));
                        GUIElement inner = new GUIElement(game, &quot;inner&quot;, RelW(g, 30), RelH(g, 20), RelW(g, 40), RelH(g, 60));
                        box.AddChild(inner);
                        inner.AddText(inner.Name, &quot;Joe has truimphed over the heroes and won the game!&quot;, new Vector2(5, 5));
                        inner.SetDrawBackground(false);

                        root.AddChild(box);
                        break;
                    }
            }

            return root;
        }

        public static GUIElement CreateMenuElement(Game game, Role role)
        {
            Contract.Requires(game != null);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;() != null);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.X == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Y == 0);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Width == game.GraphicsDevice.Viewport.Width);
            Contract.Ensures(Contract.Result&lt;GUIElement&gt;().Bound.Height == game.GraphicsDevice.Viewport.Height);

            GUIElement root = CreateEmptyRoot(game);

            if (role == Role.Overlord)
            {
                root.AddChild(new OverlordElement(game));
            }
            else
            {
                root.AddChild(new HeroElement(game, Player.Instance.Hero));
            }

            root.AddChild(new PlayersElement(game, Player.Instance.IsOverlord ? null : Player.Instance.Hero, Player.Instance.HeroParty));
            root.AddChild(new ChatElement(game));

            return root;
        }

        /// &lt;summary&gt;
        /// Creates an EquipmentElement for visualization of the properties of the given equipment. Using this method
        /// to create the element makes sure that all EquipmentElements in the game has the same dimensions and are
        /// equipped with proper click events.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;game&quot;&gt;The current Game object.&lt;/param&gt;
        /// &lt;param name=&quot;x&quot;&gt;Will be the top-left coordinate of the EquipmentElement.&lt;/param&gt;
        /// &lt;param name=&quot;y&quot;&gt;Will be the top-left coordinate of the EquipmentElement.&lt;/param&gt;
        /// &lt;param name=&quot;slotTitle&quot;&gt;In case that the equipment is null it will display this title for the missing equipment.&lt;/param&gt;
        /// &lt;param name=&quot;equipment&quot;&gt;The Equipment to visualize. Null here will indicate that the equipment slot is empty.&lt;/param&gt;
        /// &lt;param name=&quot;id&quot;&gt;The game logic ID of this equipment, will be used for the click event.&lt;/param&gt;
        /// &lt;returns&gt;A GUIElement that visualizes the given Equipment and keeps up to date if something within it changes.&lt;/returns&gt;
        public static EquipmentElement CreateEquipmentElement(Game game, int x, int y, string slotTitle, Equipment equipment, int id)
        {
            Contract.Requires(game != null);
            Contract.Ensures(Contract.Result&lt;EquipmentElement&gt;().Id == id);
            Contract.Ensures(Contract.Result&lt;EquipmentElement&gt;().Equipment == equipment);

            return new EquipmentElement(game, x, y, RelW(game.GraphicsDevice.Viewport, 12), RelH(game.GraphicsDevice.Viewport, 16), slotTitle, equipment, id);
        }

        /// &lt;summary&gt;
        /// Draws a visualization of a SurgeAbility on a target GUIElement. By using this method
        /// to draw the SurgeAbility, you're sure it's drawn the same way every time.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;target&quot;&gt;The GUIElement to draw the SurgeAbility on.&lt;/param&gt;
        /// &lt;param name=&quot;ability&quot;&gt;The SurgeAbility to display.&lt;/param&gt;
        /// &lt;param name=&quot;xPosition&quot;&gt;The top-left x-coordinate to start drawing from.&lt;/param&gt;
        /// &lt;param name=&quot;yPosition&quot;&gt;The top-left y-coordinate to start drawing from.&lt;/param&gt;
        /// &lt;param name=&quot;small&quot;&gt;True if the surge ability should be drawn as compact as possible, else false.&lt;/param&gt;
        public static void DrawSurgeAbility(GUIElement target, SurgeAbility ability, int xPosition, int yPosition, bool small)
        {
            Contract.Requires(target != null);
            Contract.Requires(ability != null);
            Contract.Requires(target.HasPoint(target.Bound.X + xPosition, target.Bound.Y + yPosition));

            // icons
            int cost = ability.Cost;
            int costX = target.Bound.X + xPosition;
            while (cost &gt; 0)
            {
                Image img = new Image(target.Game.Content.Load&lt;Texture2D&gt;(&quot;Images/Other/surge&quot;));
                target.AddDrawable(target.Name, img, new Vector2(costX, target.Bound.Y + yPosition));
                cost--;
                costX += img.Texture.Width + (small ? -5 : +2);
            }

            // text
            costX += 10;
            string s = ability.Ability.ToString();
            if (small) s = s.Replace(&quot;Damage&quot;, &quot;Dmg&quot;);
            target.AddText(target.Name, &quot;:&quot; + s, new Vector2(costX - target.Bound.X, yPosition));
        }

        /// &lt;summary&gt;
        /// Draws a given dice-type to the target GUIElement. By using this method
        /// to draw the EDice, you're sure it's drawn the same way every time.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;target&quot;&gt;The GUIElement to display the dice in.&lt;/param&gt;
        /// &lt;param name=&quot;dice&quot;&gt;The dice to display.&lt;/param&gt;
        /// &lt;param name=&quot;x&quot;&gt;The top-left x-coordinate to start drawing from.&lt;/param&gt;
        /// &lt;param name=&quot;y&quot;&gt;The top-left y-coordinate to start drawing from.&lt;/param&gt;
        /// &lt;param name=&quot;size&quot;&gt;The width and height in pixels.&lt;/param&gt;
        public static void DrawDice(GUIElement target, EDice dice, int x, int y, int size)
        {
            Contract.Requires(target != null);
            Contract.Requires(target.HasPoint(x, y));
            Contract.Requires(size &gt; 0);
            Contract.Requires(x + size &lt; target.Bound.X + target.Bound.Width);

            if (dicetinary == null) LoadDiceTextures(target.Game);

            target.AddDrawable(target.Name, new Image(dicetinary[dice]), new Rectangle(x, y, size, size));
        }

        private static void LoadDiceTextures(Game game)
        {
            dicetinary = new Dictionary&lt;EDice, Texture2D&gt;();

            dicetinary.Add(EDice.B, game.Content.Load&lt;Texture2D&gt;(&quot;Images/Other/dice-black-icon&quot;));
            dicetinary.Add(EDice.G, game.Content.Load&lt;Texture2D&gt;(&quot;Images/Other/dice-green-icon&quot;));
            dicetinary.Add(EDice.R, game.Content.Load&lt;Texture2D&gt;(&quot;Images/Other/dice-red-icon&quot;));
            dicetinary.Add(EDice.U, game.Content.Load&lt;Texture2D&gt;(&quot;Images/Other/dice-blue-icon&quot;));
            dicetinary.Add(EDice.W, game.Content.Load&lt;Texture2D&gt;(&quot;Images/Other/dice-white-icon&quot;));
            dicetinary.Add(EDice.Y, game.Content.Load&lt;Texture2D&gt;(&quot;Images/Other/dice-yellow-icon&quot;));
        }
    }
}
</pre></code><script type="text/javascript">
			applyranges('src41', RANGES_41)
		</script>
	</body>
</html>